서로 다른 목적으로 하나의 요소에 여러 이벤트 리스너가 걸릴 수 있다.
그런데 이런 상황에서 둘 다 페이지 이동을 수행한다면, 나중에 수행되는 이벤트 리스너를 실행되지 않는다.

비즈니스 목적에 따라 두 이벤트 리스너가 모두 수행된 후에 원하는 페이지로 이동하길 바랄 수 있다.

이런 경우에 각자 서로에 대한 결합도를 낮추면서 원하는 목적을 이루고 싶을 것 이다.

이를 위한 해결책으로 **CustomEvent**를 사용하는 방법이 있다.
## 공통 로직
```js
// 공통 로직
function setupNavigationCollector(element) {
  element.addEventListener("collectNavigation", (e) => {
    const { url, priority } = e.detail;
    collector.push({ url, priority });
  });
}

const collector = [];
const button = document.querySelector("#myButton");
setupNavigationCollector(button);

// 모든 클릭이 끝난 뒤 페이지 이동
button.addEventListener("click", (e) => {
  e.preventDefault();
  setTimeout(() => {
    if (collector.length === 0) return;
    const { url } = collector.sort((a, b) => b.priority - a.priority)[0];
    console.log("Navigating to:", url);
    window.location.href = url;
  });
});
```
setTimeout 을 통해 다음 틱(tick)에 동작(=모든 이벤트 리스너 실행 완료 후)
## 사용처
```js
button.addEventListener("click", (e) => {
  console.log("listener A");
  e.target.dispatchEvent(
    new CustomEvent("collectNavigation", {
      bubbles: true,
      detail: { url: "/home", priority: 5 },
    })
  );
});

button.addEventListener("click", (e) => {
  console.log("listener B");
  e.target.dispatchEvent(
    new CustomEvent("collectNavigation", {
      bubbles: true,
      detail: { url: "/dashboard", priority: 10 },
    })
  );
});
```