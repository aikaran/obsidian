서로 다른 목적으로 하나의 요소에 여러 이벤트 리스너가 걸릴 수 있다.
그런데 이런 상황에서 둘 다 페이지 이동을 수행한다면, 나중에 수행되는 이벤트 리스너를 실행되지 않는다.

비즈니스 목적에 따라 두 이벤트 리스너가 모두 수행된 후에 원하는 페이지로 이동하길 바랄 수 있다.

이런 경우에 각자 서로에 대한 결합도를 낮추면서 원하는 목적을 이루고 싶을 것 이다.

이를 위한 해결책으로 **중앙 이벤트 버스 + dispatchEvent + CustomEvent**를 사용하는 방법이 있다.
## 예제 코드
```js
const eventBus = document;
const navigationRequests = [];

// 중앙 수집기
eventBus.addEventListener("collectNavigation", (e) => {
  navigationRequests.push(e.detail);
  clearTimeout(eventBus._navTimer);

  // 짧은 지연 후 한 번만 실행
  eventBus._navTimer = setTimeout(() => {
    const best = navigationRequests.sort((a, b) => b.priority - a.priority)[0];
    if (best) {
      console.log("Final navigation:", best.url);
      window.location.href = best.url;
    }
    navigationRequests.length = 0;
  }, 0);
});

// 각 모듈에서 요청
function requestNavigation(url, priority = 1) {
  eventBus.dispatchEvent(new CustomEvent("collectNavigation", {
    bubbles: true,
    detail: { url, priority },
  }));
}
```
- setTimeout 을 통해 다음 틱(tick)에 동작(=모든 이벤트 리스너 실행 완료 후)
- clearTimeout 을 통해 동시에 여러 요청이 오더라도 디바운싱을 함
- 버블링을 통해 상위에서 한 번에 처리함